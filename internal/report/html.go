package report

import (
	"fmt"
	"html"
	"sort"
	"strings"

	"github.com/bryan-cox/taskledger/internal/jira"
	"github.com/bryan-cox/taskledger/internal/model"
)

// Section headers for HTML output.
const (
	htmlHeaderCompleted = `<h2>ü¶Ä Things I've been working on</h2>`
	htmlHeaderNextUp    = `<h2>‚≠ê Things I plan on working on next</h2>`
	htmlHeaderBlocked   = `<h2>üö´ Things that are blocking me</h2>`
)

// GenerateHTML creates an HTML version of the report.
func GenerateHTML(dates []string, completedTasks map[string][]model.TaskWithDate, nextUpTasks map[string][]model.TaskWithDate, blockedTasks []model.Task) string {
	// Process JIRA tickets and fetch summaries
	allTickets := collectAllTickets(completedTasks, nextUpTasks, blockedTasks)
	jiraInfo := jira.ProcessTickets(allTickets)

	var htmlBuilder strings.Builder

	// HTML document header
	htmlBuilder.WriteString(`<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>`)

	// Title
	htmlBuilder.WriteString(fmt.Sprintf(`<h1>Work Report (%s to %s)</h1>`, dates[0], dates[len(dates)-1]))
	htmlBuilder.WriteString(`<p><em>Autogenerated by TaskLedger</em></p>`)

	// Render each section
	htmlBuilder.WriteString(renderCompletedTasksHTML(completedTasks, jiraInfo))
	htmlBuilder.WriteString(renderNextUpTasksHTML(nextUpTasks, jiraInfo))
	htmlBuilder.WriteString(renderBlockedTasksHTML(blockedTasks, jiraInfo))

	htmlBuilder.WriteString(`</body></html>`)
	return htmlBuilder.String()
}

// collectAllTickets gathers all JIRA ticket references from categorized tasks.
func collectAllTickets(completed map[string][]model.TaskWithDate, nextUp map[string][]model.TaskWithDate, blocked []model.Task) map[string][]model.TaskWithDate {
	allTickets := make(map[string][]model.TaskWithDate)

	for ticket, tasks := range completed {
		allTickets[ticket] = tasks
	}
	for ticket, tasks := range nextUp {
		allTickets[ticket] = tasks
	}
	for _, task := range blocked {
		if task.JiraTicket != "" {
			allTickets[task.JiraTicket] = []model.TaskWithDate{{Task: task}}
		}
	}
	return allTickets
}

// renderPRLinksHTML renders a list of PR links as HTML.
func renderPRLinksHTML(prLinks map[string]bool) string {
	if len(prLinks) == 0 {
		return ""
	}

	var links []string
	for link := range prLinks {
		links = append(links, link)
	}
	sort.Strings(links)

	var sb strings.Builder
	sb.WriteString(`<li>PR(s): `)
	for i, link := range links {
		if i > 0 {
			sb.WriteString("; ")
		}
		sb.WriteString(fmt.Sprintf(`<a href="%s">%s</a>`, html.EscapeString(link), html.EscapeString(link)))
	}
	sb.WriteString(`</li>`)
	return sb.String()
}

// renderCompletedTasksHTML renders the completed tasks section as HTML.
func renderCompletedTasksHTML(tasks map[string][]model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderCompleted)
	sb.WriteString(`<ul>`)

	var tickets []string
	for t := range tasks {
		tickets = append(tickets, t)
	}
	sort.Strings(tickets)

	for _, ticket := range tickets {
		taskList := tasks[ticket]
		sort.Slice(taskList, func(i, j int) bool {
			return taskList[i].Date < taskList[j].Date
		})

		if ticket != "" {
			sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(ticket, jiraInfo)))

			var descriptions []string
			prLinks := make(map[string]bool)

			for _, taskWithDate := range taskList {
				descriptions = append(descriptions, taskWithDate.GetDescriptions()...)
				if taskWithDate.GithubPR != "" {
					prLinks[taskWithDate.GithubPR] = true
				}
			}

			sb.WriteString(`<ul>`)
			for _, desc := range descriptions {
				sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
			}
			sb.WriteString(renderPRLinksHTML(prLinks))
			sb.WriteString(`</ul></li>`)
		} else {
			sb.WriteString(`<li><ul>`)
			for _, taskWithDate := range taskList {
				for _, desc := range taskWithDate.GetDescriptions() {
					sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
				}
				if taskWithDate.GithubPR != "" {
					sb.WriteString(fmt.Sprintf(`<li>PR: <a href="%s">%s</a></li>`,
						html.EscapeString(taskWithDate.GithubPR), html.EscapeString(taskWithDate.GithubPR)))
				}
			}
			sb.WriteString(`</ul></li>`)
		}
	}
	sb.WriteString(`</ul>`)
	return sb.String()
}

// renderNextUpTasksHTML renders the next up tasks section as HTML.
func renderNextUpTasksHTML(tasks map[string][]model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderNextUp)
	sb.WriteString(`<ul>`)

	var tickets []string
	for ticket := range tasks {
		tickets = append(tickets, ticket)
	}
	sort.Strings(tickets)

	for _, ticket := range tickets {
		taskList := tasks[ticket]
		sort.Slice(taskList, func(i, j int) bool {
			return taskList[i].Date < taskList[j].Date
		})

		if ticket != "" {
			sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(ticket, jiraInfo)))

			var mostRecentDesc string
			prLinks := make(map[string]bool)

			for i := len(taskList) - 1; i >= 0; i-- {
				taskWithDate := taskList[i]
				if mostRecentDesc == "" {
					if taskWithDate.UpnextDescription != "" {
						mostRecentDesc = taskWithDate.UpnextDescription
					} else {
						allDescs := taskWithDate.GetDescriptions()
						if len(allDescs) > 0 {
							mostRecentDesc = allDescs[len(allDescs)-1]
						}
					}
				}
				if taskWithDate.GithubPR != "" {
					prLinks[taskWithDate.GithubPR] = true
				}
			}

			sb.WriteString(`<ul>`)
			if mostRecentDesc != "" {
				sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(mostRecentDesc)))
			}
			sb.WriteString(renderPRLinksHTML(prLinks))
			sb.WriteString(`</ul></li>`)
		} else {
			if len(taskList) > 0 {
				taskWithDate := taskList[len(taskList)-1]
				var desc string
				if taskWithDate.UpnextDescription != "" {
					desc = taskWithDate.UpnextDescription
				} else {
					allDescs := taskWithDate.GetDescriptions()
					if len(allDescs) > 0 {
						desc = allDescs[len(allDescs)-1]
					}
				}

				sb.WriteString(`<li><ul>`)
				sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
				if taskWithDate.GithubPR != "" {
					sb.WriteString(fmt.Sprintf(`<li>PR: <a href="%s">%s</a></li>`,
						html.EscapeString(taskWithDate.GithubPR), html.EscapeString(taskWithDate.GithubPR)))
				}
				sb.WriteString(`</ul></li>`)
			}
		}
	}
	sb.WriteString(`</ul>`)
	return sb.String()
}

// renderBlockedTasksHTML renders the blocked tasks section as HTML.
func renderBlockedTasksHTML(tasks []model.Task, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderBlocked)
	sb.WriteString(`<ul>`)

	for _, task := range tasks {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(task.JiraTicket, jiraInfo)))
		sb.WriteString(`<ul>`)
		sb.WriteString(fmt.Sprintf(`<li>Blocker: %s</li>`, html.EscapeString(task.Blocker)))
		sb.WriteString(`</ul></li>`)
	}
	sb.WriteString(`</ul>`)
	return sb.String()
}
