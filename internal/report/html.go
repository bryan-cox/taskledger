package report

import (
	"fmt"
	"html"
	"sort"
	"strings"

	"github.com/bryan-cox/taskledger/internal/jira"
	"github.com/bryan-cox/taskledger/internal/model"
)

// Section headers for HTML output.
const (
	htmlHeaderCompleted      = `<h2>ü¶Ä Things I've been working on</h2>`
	htmlHeaderNextUp         = `<h2>‚≠ê Things I plan on working on next</h2>`
	htmlHeaderBlocked        = `<h2>üö´ Things that are blocking me</h2>`
	htmlNonFeatureWorkHeader = `Non-feature work`
)

// GenerateHTML creates an HTML version of the report.
// If preloadedJiraInfo is provided (non-nil), it will be used instead of fetching from JIRA API.
func GenerateHTML(dates []string, completedTasks map[string][]model.TaskWithDate, nextUpTasks map[string][]model.TaskWithDate, blockedTasks []model.Task, preloadedJiraInfo map[string]jira.TicketInfo) string {
	// Use preloaded JIRA info if provided, otherwise fetch from API
	var jiraInfo map[string]jira.TicketInfo
	if preloadedJiraInfo != nil {
		jiraInfo = preloadedJiraInfo
	} else {
		allTickets := collectAllTickets(completedTasks, nextUpTasks, blockedTasks)
		jiraInfo = jira.ProcessTickets(allTickets)
	}

	var htmlBuilder strings.Builder

	// HTML document header
	htmlBuilder.WriteString(`<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>`)

	// Title
	htmlBuilder.WriteString(fmt.Sprintf(`<h1>Work Report (%s to %s)</h1>`, dates[0], dates[len(dates)-1]))
	htmlBuilder.WriteString(`<p><em>Autogenerated by TaskLedger</em></p>`)

	// Render each section
	htmlBuilder.WriteString(renderCompletedTasksHTML(completedTasks, jiraInfo))
	htmlBuilder.WriteString(renderNextUpTasksHTML(nextUpTasks, jiraInfo))
	htmlBuilder.WriteString(renderBlockedTasksHTML(blockedTasks, jiraInfo))

	htmlBuilder.WriteString(`</body></html>`)
	return htmlBuilder.String()
}

// collectAllTickets gathers all JIRA ticket references from categorized tasks.
func collectAllTickets(completed map[string][]model.TaskWithDate, nextUp map[string][]model.TaskWithDate, blocked []model.Task) map[string][]model.TaskWithDate {
	allTickets := make(map[string][]model.TaskWithDate)

	for ticket, tasks := range completed {
		allTickets[ticket] = tasks
	}
	for ticket, tasks := range nextUp {
		allTickets[ticket] = tasks
	}
	for _, task := range blocked {
		if task.JiraTicket != "" {
			allTickets[task.JiraTicket] = []model.TaskWithDate{{Task: task}}
		}
	}
	return allTickets
}

// renderPRLinksHTML renders a list of PR links as HTML.
func renderPRLinksHTML(prLinks map[string]bool) string {
	if len(prLinks) == 0 {
		return ""
	}

	var links []string
	for link := range prLinks {
		links = append(links, link)
	}
	sort.Strings(links)

	var sb strings.Builder
	sb.WriteString(`<li>PR(s): `)
	for i, link := range links {
		if i > 0 {
			sb.WriteString("; ")
		}
		sb.WriteString(fmt.Sprintf(`<a href="%s">%s</a>`, html.EscapeString(link), html.EscapeString(link)))
	}
	sb.WriteString(`</li>`)
	return sb.String()
}

// renderCompletedTasksHTML renders the completed tasks section as HTML.
func renderCompletedTasksHTML(tasks map[string][]model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderCompleted)
	sb.WriteString(`<ul>`)

	// Separate feature work and non-feature work
	var featureTickets []string
	var nonFeatureTickets []string

	for ticket := range tasks {
		taskList := tasks[ticket]
		// Check if any task in the group has a PR (for NO-JIRA check)
		hasPR := false
		for _, t := range taskList {
			if t.GithubPR != "" {
				hasPR = true
				break
			}
		}

		prArg := ""
		if hasPR {
			prArg = "has-pr"
		}

		if IsNonFeatureWork(ticket, prArg) {
			nonFeatureTickets = append(nonFeatureTickets, ticket)
		} else {
			featureTickets = append(featureTickets, ticket)
		}
	}
	sort.Strings(featureTickets)
	sort.Strings(nonFeatureTickets)

	// Render feature work first
	for _, ticket := range featureTickets {
		sb.WriteString(renderTicketEntryHTML(ticket, tasks[ticket], jiraInfo))
	}

	// Render non-feature work at the end (grouped under "Non-feature work" with sub-entries)
	if len(nonFeatureTickets) > 0 {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, htmlNonFeatureWorkHeader))
		sb.WriteString(`<ul>`)
		for _, ticket := range nonFeatureTickets {
			sb.WriteString(renderNonFeatureSubEntryHTML(ticket, tasks[ticket]))
		}
		sb.WriteString(`</ul></li>`)
	}

	sb.WriteString(`</ul>`)
	return sb.String()
}

// renderTicketEntryHTML renders a single ticket entry with its descriptions and PRs.
func renderTicketEntryHTML(ticket string, taskList []model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	sort.Slice(taskList, func(i, j int) bool {
		return taskList[i].Date < taskList[j].Date
	})

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(ticket, jiraInfo)))

	var descriptions []string
	prLinks := make(map[string]bool)

	for _, taskWithDate := range taskList {
		descriptions = append(descriptions, taskWithDate.GetDescriptions()...)
		if taskWithDate.GithubPR != "" {
			prLinks[taskWithDate.GithubPR] = true
		}
	}

	sb.WriteString(`<ul>`)
	for _, desc := range descriptions {
		sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
	}
	sb.WriteString(renderPRLinksHTML(prLinks))
	sb.WriteString(`</ul></li>`)

	return sb.String()
}

// renderNonFeatureSubEntryHTML renders a non-feature work sub-entry with ticket name as header and descriptions as nested bullets.
func renderNonFeatureSubEntryHTML(ticket string, taskList []model.TaskWithDate) string {
	sort.Slice(taskList, func(i, j int) bool {
		return taskList[i].Date < taskList[j].Date
	})

	var descriptions []string
	prLinks := make(map[string]bool)

	for _, taskWithDate := range taskList {
		descriptions = append(descriptions, taskWithDate.GetDescriptions()...)
		if taskWithDate.GithubPR != "" {
			prLinks[taskWithDate.GithubPR] = true
		}
	}

	var sb strings.Builder

	// Use ticket text as the sub-entry header (or "Misc" if empty)
	header := ticket
	if header == "" {
		header = "Misc"
	}
	sb.WriteString(fmt.Sprintf(`<li>%s`, html.EscapeString(header)))

	if len(descriptions) > 0 || len(prLinks) > 0 {
		sb.WriteString(`<ul>`)
		for _, desc := range descriptions {
			sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
		}
		sb.WriteString(renderPRLinksHTML(prLinks))
		sb.WriteString(`</ul>`)
	}
	sb.WriteString(`</li>`)

	return sb.String()
}

// renderNextUpTasksHTML renders the next up tasks section as HTML.
func renderNextUpTasksHTML(tasks map[string][]model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderNextUp)
	sb.WriteString(`<ul>`)

	// Separate feature work and non-feature work
	var featureTickets []string
	var nonFeatureTickets []string

	for ticket := range tasks {
		taskList := tasks[ticket]
		// Check if any task in the group has a PR (for NO-JIRA check)
		hasPR := false
		for _, t := range taskList {
			if t.GithubPR != "" {
				hasPR = true
				break
			}
		}

		prArg := ""
		if hasPR {
			prArg = "has-pr"
		}

		if IsNonFeatureWork(ticket, prArg) {
			nonFeatureTickets = append(nonFeatureTickets, ticket)
		} else {
			featureTickets = append(featureTickets, ticket)
		}
	}
	sort.Strings(featureTickets)
	sort.Strings(nonFeatureTickets)

	// Render feature work first
	for _, ticket := range featureTickets {
		sb.WriteString(renderNextUpTicketEntryHTML(ticket, tasks[ticket], jiraInfo))
	}

	// Render non-feature work at the end (grouped under "Non-feature work" with sub-entries)
	if len(nonFeatureTickets) > 0 {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, htmlNonFeatureWorkHeader))
		sb.WriteString(`<ul>`)
		for _, ticket := range nonFeatureTickets {
			sb.WriteString(renderNonFeatureNextUpSubEntryHTML(ticket, tasks[ticket]))
		}
		sb.WriteString(`</ul></li>`)
	}

	sb.WriteString(`</ul>`)
	return sb.String()
}

// renderNextUpTicketEntryHTML renders a single next up ticket entry.
func renderNextUpTicketEntryHTML(ticket string, taskList []model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	sort.Slice(taskList, func(i, j int) bool {
		return taskList[i].Date < taskList[j].Date
	})

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(ticket, jiraInfo)))

	var mostRecentDesc string
	prLinks := make(map[string]bool)

	for i := len(taskList) - 1; i >= 0; i-- {
		taskWithDate := taskList[i]
		if mostRecentDesc == "" {
			if taskWithDate.UpnextDescription != "" {
				mostRecentDesc = taskWithDate.UpnextDescription
			} else {
				allDescs := taskWithDate.GetDescriptions()
				if len(allDescs) > 0 {
					mostRecentDesc = allDescs[len(allDescs)-1]
				}
			}
		}
		if taskWithDate.GithubPR != "" {
			prLinks[taskWithDate.GithubPR] = true
		}
	}

	sb.WriteString(`<ul>`)
	if mostRecentDesc != "" {
		sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(mostRecentDesc)))
	}
	sb.WriteString(renderPRLinksHTML(prLinks))
	sb.WriteString(`</ul></li>`)

	return sb.String()
}

// renderNonFeatureNextUpSubEntryHTML renders a non-feature next up sub-entry.
func renderNonFeatureNextUpSubEntryHTML(ticket string, taskList []model.TaskWithDate) string {
	sort.Slice(taskList, func(i, j int) bool {
		return taskList[i].Date < taskList[j].Date
	})

	var mostRecentDesc string
	prLinks := make(map[string]bool)

	for i := len(taskList) - 1; i >= 0; i-- {
		taskWithDate := taskList[i]
		if mostRecentDesc == "" {
			if taskWithDate.UpnextDescription != "" {
				mostRecentDesc = taskWithDate.UpnextDescription
			} else {
				allDescs := taskWithDate.GetDescriptions()
				if len(allDescs) > 0 {
					mostRecentDesc = allDescs[len(allDescs)-1]
				}
			}
		}
		if taskWithDate.GithubPR != "" {
			prLinks[taskWithDate.GithubPR] = true
		}
	}

	var sb strings.Builder
	header := ticket
	if header == "" {
		header = "Misc"
	}
	sb.WriteString(fmt.Sprintf(`<li>%s`, html.EscapeString(header)))

	if mostRecentDesc != "" || len(prLinks) > 0 {
		sb.WriteString(`<ul>`)
		if mostRecentDesc != "" {
			sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(mostRecentDesc)))
		}
		sb.WriteString(renderPRLinksHTML(prLinks))
		sb.WriteString(`</ul>`)
	}
	sb.WriteString(`</li>`)

	return sb.String()
}

// renderBlockedTasksHTML renders the blocked tasks section as HTML.
func renderBlockedTasksHTML(tasks []model.Task, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	// Separate feature work and non-feature work
	var featureTasks []model.Task
	var nonFeatureTasks []model.Task

	for _, task := range tasks {
		if IsNonFeatureWork(task.JiraTicket, task.GithubPR) {
			nonFeatureTasks = append(nonFeatureTasks, task)
		} else {
			featureTasks = append(featureTasks, task)
		}
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderBlocked)
	sb.WriteString(`<ul>`)

	// Render feature work first
	for _, task := range featureTasks {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(task.JiraTicket, jiraInfo)))
		sb.WriteString(`<ul>`)
		sb.WriteString(fmt.Sprintf(`<li>Blocker: %s</li>`, html.EscapeString(task.Blocker)))
		sb.WriteString(`</ul></li>`)
	}

	// Render non-feature work at the end (grouped under "Non-feature work" with sub-entries)
	if len(nonFeatureTasks) > 0 {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, htmlNonFeatureWorkHeader))
		sb.WriteString(`<ul>`)
		for _, task := range nonFeatureTasks {
			header := task.JiraTicket
			if header == "" {
				header = "Misc"
			}
			sb.WriteString(fmt.Sprintf(`<li>%s`, html.EscapeString(header)))
			sb.WriteString(`<ul>`)
			sb.WriteString(fmt.Sprintf(`<li>Blocker: %s</li>`, html.EscapeString(task.Blocker)))
			sb.WriteString(`</ul></li>`)
		}
		sb.WriteString(`</ul></li>`)
	}

	sb.WriteString(`</ul>`)
	return sb.String()
}
