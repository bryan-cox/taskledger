package report

import (
	"fmt"
	"html"
	"sort"
	"strings"

	"github.com/bryan-cox/taskledger/internal/jira"
	"github.com/bryan-cox/taskledger/internal/model"
)

// Section headers for HTML output.
const (
	htmlHeaderCompleted      = `<h2>ü¶Ä Things I've been working on</h2>`
	htmlHeaderNextUp         = `<h2>‚≠ê Things I plan on working on next</h2>`
	htmlHeaderBlocked        = `<h2>üö´ Things that are blocking me</h2>`
	htmlNonFeatureWorkHeader = `Non-feature work`
)

// GenerateHTML creates an HTML version of the report.
// If preloadedJiraInfo is provided (non-nil), it will be used instead of fetching from JIRA API.
func GenerateHTML(dates []string, completedTasks map[string][]model.TaskWithDate, nextUpTasks map[string][]model.TaskWithDate, blockedTasks []model.Task, preloadedJiraInfo map[string]jira.TicketInfo) string {
	// Use preloaded JIRA info if provided, otherwise fetch from API
	var jiraInfo map[string]jira.TicketInfo
	if preloadedJiraInfo != nil {
		jiraInfo = preloadedJiraInfo
	} else {
		allTickets := collectAllTickets(completedTasks, nextUpTasks, blockedTasks)
		jiraInfo = jira.ProcessTickets(allTickets)
	}

	var htmlBuilder strings.Builder

	// HTML document header
	htmlBuilder.WriteString(`<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>`)

	// Title
	htmlBuilder.WriteString(fmt.Sprintf(`<h1>Work Report (%s to %s)</h1>`, dates[0], dates[len(dates)-1]))
	htmlBuilder.WriteString(`<p><em>Autogenerated by TaskLedger</em></p>`)

	// Render each section
	htmlBuilder.WriteString(renderCompletedTasksHTML(completedTasks, jiraInfo))
	htmlBuilder.WriteString(renderNextUpTasksHTML(nextUpTasks, jiraInfo))
	htmlBuilder.WriteString(renderBlockedTasksHTML(blockedTasks, jiraInfo))

	htmlBuilder.WriteString(`</body></html>`)
	return htmlBuilder.String()
}

// collectAllTickets gathers all JIRA ticket references from categorized tasks.
func collectAllTickets(completed map[string][]model.TaskWithDate, nextUp map[string][]model.TaskWithDate, blocked []model.Task) map[string][]model.TaskWithDate {
	allTickets := make(map[string][]model.TaskWithDate)

	for ticket, tasks := range completed {
		allTickets[ticket] = tasks
	}
	for ticket, tasks := range nextUp {
		allTickets[ticket] = tasks
	}
	for _, task := range blocked {
		if task.JiraTicket != "" {
			allTickets[task.JiraTicket] = []model.TaskWithDate{{Task: task}}
		}
	}
	return allTickets
}

// renderPRLinksHTML renders a list of PR links as HTML.
func renderPRLinksHTML(prLinks map[string]bool) string {
	if len(prLinks) == 0 {
		return ""
	}

	var links []string
	for link := range prLinks {
		links = append(links, link)
	}
	sort.Strings(links)

	var sb strings.Builder
	sb.WriteString(`<li>PR(s): `)
	for i, link := range links {
		if i > 0 {
			sb.WriteString("; ")
		}
		sb.WriteString(fmt.Sprintf(`<a href="%s">%s</a>`, html.EscapeString(link), html.EscapeString(link)))
	}
	sb.WriteString(`</li>`)
	return sb.String()
}

// renderCompletedTasksHTML renders the completed tasks section as HTML.
func renderCompletedTasksHTML(tasks map[string][]model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderCompleted)
	sb.WriteString(`<ul>`)

	// Separate feature work and non-feature work
	var featureTickets []string
	var nonFeatureDescriptions []string
	nonFeaturePRLinks := make(map[string]bool)

	for ticket := range tasks {
		taskList := tasks[ticket]
		// Check if any task in the group has a PR (for NO-JIRA check)
		hasPR := false
		for _, t := range taskList {
			if t.GithubPR != "" {
				hasPR = true
				break
			}
		}

		if IsNonFeatureWork(ticket, func() string {
			if hasPR {
				return "has-pr"
			}
			return ""
		}()) {
			// Collect non-feature work descriptions and PRs
			for _, taskWithDate := range taskList {
				nonFeatureDescriptions = append(nonFeatureDescriptions, taskWithDate.GetDescriptions()...)
				if taskWithDate.GithubPR != "" {
					nonFeaturePRLinks[taskWithDate.GithubPR] = true
				}
			}
		} else {
			featureTickets = append(featureTickets, ticket)
		}
	}
	sort.Strings(featureTickets)

	// Render feature work first
	for _, ticket := range featureTickets {
		taskList := tasks[ticket]
		sort.Slice(taskList, func(i, j int) bool {
			return taskList[i].Date < taskList[j].Date
		})

		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(ticket, jiraInfo)))

		var descriptions []string
		prLinks := make(map[string]bool)

		for _, taskWithDate := range taskList {
			descriptions = append(descriptions, taskWithDate.GetDescriptions()...)
			if taskWithDate.GithubPR != "" {
				prLinks[taskWithDate.GithubPR] = true
			}
		}

		sb.WriteString(`<ul>`)
		for _, desc := range descriptions {
			sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
		}
		sb.WriteString(renderPRLinksHTML(prLinks))
		sb.WriteString(`</ul></li>`)
	}

	// Render non-feature work at the end
	if len(nonFeatureDescriptions) > 0 {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, htmlNonFeatureWorkHeader))
		sb.WriteString(`<ul>`)
		for _, desc := range nonFeatureDescriptions {
			sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
		}
		sb.WriteString(renderPRLinksHTML(nonFeaturePRLinks))
		sb.WriteString(`</ul></li>`)
	}

	sb.WriteString(`</ul>`)
	return sb.String()
}

// renderNextUpTasksHTML renders the next up tasks section as HTML.
func renderNextUpTasksHTML(tasks map[string][]model.TaskWithDate, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderNextUp)
	sb.WriteString(`<ul>`)

	// Separate feature work and non-feature work
	var featureTickets []string
	var nonFeatureDescriptions []string
	nonFeaturePRLinks := make(map[string]bool)

	for ticket := range tasks {
		taskList := tasks[ticket]
		// Check if any task in the group has a PR (for NO-JIRA check)
		hasPR := false
		for _, t := range taskList {
			if t.GithubPR != "" {
				hasPR = true
				break
			}
		}

		if IsNonFeatureWork(ticket, func() string {
			if hasPR {
				return "has-pr"
			}
			return ""
		}()) {
			// Collect non-feature work descriptions (most recent per ticket group)
			sort.Slice(taskList, func(i, j int) bool {
				return taskList[i].Date < taskList[j].Date
			})
			for i := len(taskList) - 1; i >= 0; i-- {
				taskWithDate := taskList[i]
				var desc string
				if taskWithDate.UpnextDescription != "" {
					desc = taskWithDate.UpnextDescription
				} else {
					allDescs := taskWithDate.GetDescriptions()
					if len(allDescs) > 0 {
						desc = allDescs[len(allDescs)-1]
					}
				}
				if desc != "" {
					nonFeatureDescriptions = append(nonFeatureDescriptions, desc)
					break
				}
				if taskWithDate.GithubPR != "" {
					nonFeaturePRLinks[taskWithDate.GithubPR] = true
				}
			}
		} else {
			featureTickets = append(featureTickets, ticket)
		}
	}
	sort.Strings(featureTickets)

	// Render feature work first
	for _, ticket := range featureTickets {
		taskList := tasks[ticket]
		sort.Slice(taskList, func(i, j int) bool {
			return taskList[i].Date < taskList[j].Date
		})

		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(ticket, jiraInfo)))

		var mostRecentDesc string
		prLinks := make(map[string]bool)

		for i := len(taskList) - 1; i >= 0; i-- {
			taskWithDate := taskList[i]
			if mostRecentDesc == "" {
				if taskWithDate.UpnextDescription != "" {
					mostRecentDesc = taskWithDate.UpnextDescription
				} else {
					allDescs := taskWithDate.GetDescriptions()
					if len(allDescs) > 0 {
						mostRecentDesc = allDescs[len(allDescs)-1]
					}
				}
			}
			if taskWithDate.GithubPR != "" {
				prLinks[taskWithDate.GithubPR] = true
			}
		}

		sb.WriteString(`<ul>`)
		if mostRecentDesc != "" {
			sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(mostRecentDesc)))
		}
		sb.WriteString(renderPRLinksHTML(prLinks))
		sb.WriteString(`</ul></li>`)
	}

	// Render non-feature work at the end
	if len(nonFeatureDescriptions) > 0 {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, htmlNonFeatureWorkHeader))
		sb.WriteString(`<ul>`)
		for _, desc := range nonFeatureDescriptions {
			sb.WriteString(fmt.Sprintf(`<li>%s</li>`, html.EscapeString(desc)))
		}
		sb.WriteString(renderPRLinksHTML(nonFeaturePRLinks))
		sb.WriteString(`</ul></li>`)
	}

	sb.WriteString(`</ul>`)
	return sb.String()
}

// renderBlockedTasksHTML renders the blocked tasks section as HTML.
func renderBlockedTasksHTML(tasks []model.Task, jiraInfo map[string]jira.TicketInfo) string {
	if len(tasks) == 0 {
		return ""
	}

	// Separate feature work and non-feature work
	var featureTasks []model.Task
	var nonFeatureBlockers []string

	for _, task := range tasks {
		if IsNonFeatureWork(task.JiraTicket, task.GithubPR) {
			nonFeatureBlockers = append(nonFeatureBlockers, task.Blocker)
		} else {
			featureTasks = append(featureTasks, task)
		}
	}

	var sb strings.Builder
	sb.WriteString(htmlHeaderBlocked)
	sb.WriteString(`<ul>`)

	// Render feature work first
	for _, task := range featureTasks {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, jira.FormatTicketHTML(task.JiraTicket, jiraInfo)))
		sb.WriteString(`<ul>`)
		sb.WriteString(fmt.Sprintf(`<li>Blocker: %s</li>`, html.EscapeString(task.Blocker)))
		sb.WriteString(`</ul></li>`)
	}

	// Render non-feature work at the end
	if len(nonFeatureBlockers) > 0 {
		sb.WriteString(fmt.Sprintf(`<li><strong>%s</strong>`, htmlNonFeatureWorkHeader))
		sb.WriteString(`<ul>`)
		for _, blocker := range nonFeatureBlockers {
			sb.WriteString(fmt.Sprintf(`<li>Blocker: %s</li>`, html.EscapeString(blocker)))
		}
		sb.WriteString(`</ul></li>`)
	}

	sb.WriteString(`</ul>`)
	return sb.String()
}
