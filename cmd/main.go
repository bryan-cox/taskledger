package main

import (
	"fmt"
	"io"
	"log/slog"
	"os"
	"os/exec"
	"runtime"
	"sort"
	"time"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/bryan-cox/taskledger/internal/clipboard"
	"github.com/bryan-cox/taskledger/internal/model"
	"github.com/bryan-cox/taskledger/internal/report"
)

// --- CLI Flags ---

var (
	filePath  string
	startDate string
	endDate   string
	copyHTML  bool
	htmlFile  string
	showHTML  bool
	openHTML  bool
)

// --- Cobra Command Definitions ---

var (
	rootCmd = &cobra.Command{
		Use:   "taskledger",
		Short: "A CLI tool to track work and generate reports from a YAML log.",
		Long:  `TaskLedger is a command-line interface for parsing a work log YAML file to calculate hours worked and generate status reports.`,
	}

	hoursCmd = &cobra.Command{
		Use:   "hours",
		Short: "Calculate total hours worked.",
		Long:  `Calculates the total work hours based on the start and end times in the worklog.yml file. You can specify a single date or a range.`,
		Run:   runHoursCommand,
	}

	reportCmd = &cobra.Command{
		Use:   "report",
		Short: "Generate a human-readable work report.",
		Long:  `Generates a formatted text report detailing completed tasks, blockers, and ongoing work for the specified date or date range.`,
		Run:   runReportCommand,
	}

	initCmd = &cobra.Command{
		Use:   "init",
		Short: "Create a new worklog.yml file with example entries.",
		Long:  `Creates a new worklog.yml file populated with example entries for the last two days, showing all available fields.`,
		Run:   runInitCommand,
	}
)

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

func init() {
	rootCmd.PersistentFlags().StringVar(&filePath, "file", "worklog.yml", "Path to the YAML work log file.")

	hoursCmd.Flags().StringVar(&startDate, "start-date", "", "Start date (YYYY-MM-DD).")
	hoursCmd.Flags().StringVar(&endDate, "end-date", "", "End date (YYYY-MM-DD).")

	reportCmd.Flags().StringVar(&startDate, "start-date", "", "Start date (YYYY-MM-DD).")
	reportCmd.Flags().StringVar(&endDate, "end-date", "", "End date (YYYY-MM-DD).")
	reportCmd.Flags().BoolVar(&copyHTML, "copy-html", false, "Attempt to copy the report as formatted HTML to clipboard.")
	reportCmd.Flags().StringVar(&htmlFile, "html-file", "", "Save the report as HTML to the specified file.")
	reportCmd.Flags().BoolVar(&showHTML, "show-html", false, "Display the HTML content in the terminal.")
	reportCmd.Flags().BoolVar(&openHTML, "open-html", false, "Automatically open the HTML file in the default browser after saving.")

	rootCmd.AddCommand(hoursCmd)
	rootCmd.AddCommand(reportCmd)
	rootCmd.AddCommand(initCmd)
}

// --- Main Entry Point ---

func main() {
	logger := slog.New(slog.NewJSONHandler(os.Stderr, nil))
	slog.SetDefault(logger)
	Execute()
}

// --- Command Handlers ---

func runHoursCommand(cmd *cobra.Command, args []string) {
	workData, err := loadWorkData(filePath)
	if err != nil {
		slog.Error("failed to load work log file", "error", err, "path", filePath)
		os.Exit(1)
	}

	dates, err := getDatesInRange(workData, startDate, endDate)
	if err != nil {
		slog.Error("failed to process date range", "error", err, "start_date", startDate, "end_date", endDate)
		os.Exit(1)
	}

	var totalDuration time.Duration
	for _, date := range dates {
		dailyLog, exists := workData[date]
		if !exists {
			continue
		}
		for _, logEntry := range dailyLog.WorkLogEntries {
			start, err1 := time.Parse("15:04", logEntry.StartTime)
			end, err2 := time.Parse("15:04", logEntry.EndTime)
			if err1 != nil || err2 != nil {
				slog.Warn("could not parse time entry, skipping", "date", date, "entry", logEntry)
				continue
			}
			totalDuration += end.Sub(start)
		}
	}

	cmd.Printf("Total hours worked from %s to %s: %.2f\n", dates[0], dates[len(dates)-1], totalDuration.Hours())
}

func runReportCommand(cmd *cobra.Command, args []string) {
	workData, err := loadWorkData(filePath)
	if err != nil {
		slog.Error("failed to load work log file", "error", err, "path", filePath)
		os.Exit(1)
	}

	dates, err := getDatesInRange(workData, startDate, endDate)
	if err != nil {
		slog.Error("failed to process date range", "error", err, "start_date", startDate, "end_date", endDate)
		os.Exit(1)
	}

	// Categorize tasks into completed, next up, and blocked
	tasks := report.CategorizeTasks(workData, dates)

	// Generate and print the human-readable report to standard output
	out := cmd.OutOrStdout()
	fmt.Fprintf(out, "Work Report (%s to %s)\n", dates[0], dates[len(dates)-1])
	fmt.Fprintln(out, "=======Autogenerated by TaskLedger=======")

	report.PrintCompletedTasks(out, tasks.Completed)
	report.PrintNextUpTasks(out, tasks.NextUp)
	report.PrintBlockedTasks(out, tasks.Blocked)

	// Handle HTML output options
	if copyHTML || htmlFile != "" || showHTML || openHTML {
		htmlContent := report.GenerateHTML(dates, tasks.Completed, tasks.NextUp, tasks.Blocked)
		handleHTMLOutput(out, htmlContent)
	}
}

func runInitCommand(cmd *cobra.Command, args []string) {
	// Check if file already exists
	if _, err := os.Stat(filePath); err == nil {
		fmt.Fprintf(cmd.OutOrStdout(), "File '%s' already exists. Overwrite? (y/N): ", filePath)
		var response string
		fmt.Scanln(&response)
		if response != "y" && response != "Y" {
			fmt.Fprintln(cmd.OutOrStdout(), "Init cancelled.")
			return
		}
	}

	// Generate sample worklog data for today and yesterday
	data, err := generateInitialWorklogYAML(time.Now())
	if err != nil {
		slog.Error("failed to generate worklog YAML", "error", err)
		os.Exit(1)
	}

	// Write to file
	err = os.WriteFile(filePath, data, 0644)
	if err != nil {
		slog.Error("failed to write worklog file", "error", err, "path", filePath)
		os.Exit(1)
	}

	fmt.Fprintf(cmd.OutOrStdout(), "‚úÖ Created %s with sample entries for today and yesterday.\n", filePath)
	fmt.Fprintln(cmd.OutOrStdout(), "Edit the file to add your own work entries!")
}

// --- HTML Output Handling ---

func handleHTMLOutput(out io.Writer, htmlContent string) {
	// Save to file if requested
	if htmlFile != "" {
		err := saveHTMLToFile(htmlContent, htmlFile)
		if err != nil {
			slog.Error("failed to save HTML to file", "error", err, "file", htmlFile)
		} else {
			fmt.Fprintf(out, "\n‚úÖ HTML report saved to: %s\n", htmlFile)

			// Open HTML file in browser if requested
			if openHTML {
				err := openHTMLInBrowser(htmlFile)
				if err != nil {
					fmt.Fprintf(out, "‚ö†Ô∏è  Failed to open HTML file in browser: %v\n", err)
				} else {
					fmt.Fprintf(out, "üåê Opened HTML report in default browser\n")
				}
			}
		}
	} else if openHTML {
		fmt.Fprintf(out, "\nüí° To use --open-html, you must also specify --html-file\n")
	}

	// Show HTML in console if requested
	if showHTML {
		fmt.Fprintln(out, "\n=== HTML OUTPUT ===")
		fmt.Fprintln(out, htmlContent)
		fmt.Fprintln(out, "=== END HTML OUTPUT ===")
	}

	// Try to copy to clipboard if requested
	if copyHTML {
		err := clipboard.CopyHTML(htmlContent)
		if err != nil {
			fmt.Fprintf(out, "\n‚ö†Ô∏è  Failed to copy to clipboard: %v\n", err)
			fmt.Fprintf(out, "üí° Try using --html-file to save to a file instead, or --show-html to display the HTML\n")
		} else {
			fmt.Fprintln(out, "\n‚úÖ HTML report copied to clipboard!")
		}
	}
}

// --- File Operations ---

func saveHTMLToFile(htmlContent, filename string) error {
	return os.WriteFile(filename, []byte(htmlContent), 0644)
}

func openHTMLInBrowser(filePath string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin":
		cmd = exec.Command("open", filePath)
	case "linux":
		cmd = exec.Command("xdg-open", filePath)
	case "windows":
		cmd = exec.Command("cmd", "/c", "start", "", filePath)
	default:
		return fmt.Errorf("unsupported platform: %s", runtime.GOOS)
	}

	return cmd.Start()
}

// --- Data Loading ---

func loadWorkData(filePath string) (model.WorkData, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("could not read file '%s': %w", filePath, err)
	}

	var workData model.WorkData
	err = yaml.Unmarshal(data, &workData)
	if err != nil {
		return nil, fmt.Errorf("could not parse YAML from '%s': %w", filePath, err)
	}

	return workData, nil
}

func getDatesInRange(workData model.WorkData, startStr, endStr string) ([]string, error) {
	if startStr != "" && endStr == "" {
		endStr = startStr
	}
	if endStr != "" && startStr == "" {
		startStr = endStr
	}

	if startStr == "" && endStr == "" {
		var allDates []string
		for date := range workData {
			allDates = append(allDates, date)
		}
		sort.Strings(allDates)
		if len(allDates) == 0 {
			return nil, fmt.Errorf("no data found in the work log file")
		}
		return allDates, nil
	}

	startDate, err := time.Parse("2006-01-02", startStr)
	if err != nil {
		return nil, fmt.Errorf("invalid start date format, use YYYY-MM-DD: %w", err)
	}
	endDate, err := time.Parse("2006-01-02", endStr)
	if err != nil {
		return nil, fmt.Errorf("invalid end date format, use YYYY-MM-DD: %w", err)
	}

	if endDate.Before(startDate) {
		return nil, fmt.Errorf("end date cannot be before start date")
	}

	var datesInRange []string
	for d := startDate; !d.After(endDate); d = d.AddDate(0, 0, 1) {
		dateStr := d.Format("2006-01-02")
		if _, exists := workData[dateStr]; exists {
			datesInRange = append(datesInRange, dateStr)
		}
	}

	if len(datesInRange) == 0 {
		return nil, fmt.Errorf("no data found for the specified date range")
	}
	sort.Strings(datesInRange)
	return datesInRange, nil
}

// --- Init Command Helpers ---

func generateInitialWorklogYAML(now time.Time) ([]byte, error) {
	workData := createInitialWorklog(now)
	return yaml.Marshal(workData)
}

func createInitialWorklog(now time.Time) model.WorkData {
	yesterday := now.AddDate(0, 0, -1)

	workData := model.WorkData{
		yesterday.Format("2006-01-02"): model.DailyLog{
			WorkLogEntries: []model.WorkLog{
				{StartTime: "09:00", EndTime: "12:00"},
				{StartTime: "13:00", EndTime: "17:00"},
			},
			Tasks: []model.Task{
				{
					Status:      "completed",
					Description: "Fixed bug in authentication flow",
					JiraTicket:  "PROJ-1234",
					GithubPR:    "https://github.com/example/repo/pull/42",
					QCGoal:      "Ensure users can log in successfully",
				},
				{
					Status:            "in progress",
					Descriptions:      []string{"Refactored database queries", "Added connection pooling"},
					JiraTicket:        "PROJ-5678",
					UpnextDescription: "Add query performance monitoring",
				},
			},
		},
		now.Format("2006-01-02"): model.DailyLog{
			WorkLogEntries: []model.WorkLog{
				{StartTime: "09:30", EndTime: "12:30"},
				{StartTime: "13:30", EndTime: "16:00"},
			},
			Tasks: []model.Task{
				{
					Status:            "in progress",
					Description:       "Implemented new API endpoint for user profiles",
					JiraTicket:        "PROJ-5678",
					GithubPR:          "https://github.com/example/repo/pull/43",
					UpnextDescription: "Add authentication middleware to endpoint",
				},
				{
					Status:     "not started",
					JiraTicket: "PROJ-9999",
					Blocker:    "Waiting for design approval from UX team",
				},
			},
		},
	}

	return workData
}
